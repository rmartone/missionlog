{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/**\n * @author Ray Martone\n * @copyright Copyright (c) 2019-2022 Ray Martone\n * @license MIT\n * @description log adapter that provides level based filtering and tagging\n */\n\n// missionlog\n\n/**\n * Numeric representation of log levels, where ERROR > WARN > INFO.\n */\nenum Level {\n  TRACE = 1,\n  DEBUG,\n  INFO,\n  WARN,\n  ERROR,\n  OFF,\n}\n\n/**\n * Log levels for event handling.\n */\nexport enum LogLevel {\n  TRACE = 'TRACE',\n  DEBUG = 'DEBUG',\n  INFO = 'INFO',\n  WARN = 'WARN',\n  ERROR = 'ERROR',\n  OFF = 'OFF',\n}\n\n/**\n * Log callback function type.\n */\nexport type LogCallback = (level: LogLevelStr, tag: string, message: unknown, optionalParams: unknown[]) => void;\n\n/**\n * Union type for log level strings.\n */\nexport type LogLevelStr = 'DEBUG' | 'TRACE' | 'INFO' | 'WARN' | 'ERROR' | 'OFF';\n\n/**\n * Tag registry.\n */\nexport const tagRegistry: Record<string, string> = {};\n\n/**\n * Log class for level-based filtering and tagging.\n */\nexport class Log {\n  /**\n   * Default log level if not specified in tag config.\n   */\n  private readonly _defaultLevel: Level = Level.INFO;\n\n  /**\n   * Tag to level mapping.\n   */\n  protected readonly _tagToLevel: Record<string, Level> = {};\n\n  /**\n   * Log callback function.\n   */\n  protected _callback?: LogCallback;\n\n  /**\n   * Converts a log level string to its corresponding numeric Level.\n   * Marked as protected so that it\u2019s available on the instance.\n   *\n   * @param levelStr Log level as a string.\n   * @returns Numeric log level.\n   */\n  protected parseLevel(levelStr: LogLevelStr): Level | undefined {\n    return Level[levelStr];\n  }\n\n  /**\n   * Converts a numeric log level to its corresponding log level string.\n   * Marked as protected so that it\u2019s available on the instance.\n   *\n   * @param level Numeric log level.\n   * @returns Log level as a string.\n   */\n  protected levelToString(level: Level): LogLevelStr {\n    return Level[level] as LogLevelStr;\n  }\n\n  /**\n   * Initializes the logger.\n   *\n   * @param config Optional configuration object mapping tags to log levels. Defaults to INFO if not specified.\n   * @param callback Optional callback function for log events.\n   * @returns The Log instance for chaining.\n   */\n  init(config?: Record<string, string>, callback?: LogCallback): this {\n    if (config) {\n      for (const key in config) {\n        const levelStr = config[key] as LogLevelStr;\n        const level = this.parseLevel(levelStr);\n        if (level !== undefined) {\n          this._tagToLevel[key] = level;\n        } else {\n          console.warn(`Invalid log level \"${levelStr}\" for tag \"${key}\". Using INFO.`);\n          this._tagToLevel[key] = this._defaultLevel;\n        }\n\n        tagRegistry[key] = key;\n      }\n    }\n    if (callback) {\n      this._callback = callback;\n    }\n    return this;\n  }\n\n  /**\n   * Logs a debug message.\n   *\n   * @param tag Message category.\n   * @param message Message to log.\n   * @param optionalParams Optional parameters to log.\n   */\n  debug<T extends string>(tag: T, message: unknown, ...optionalParams: unknown[]): void {\n    this.log(Level.DEBUG, tag, message, optionalParams);\n  }\n\n  /**\n   * Logs an error message.\n   *\n   * @param tag Message category.\n   * @param message Message to log.\n   * @param optionalParams Optional parameters to log.\n   */\n  error<T extends string>(tag: T, message: unknown, ...optionalParams: unknown[]): void {\n    this.log(Level.ERROR, tag, message, optionalParams);\n  }\n\n  /**\n   * Logs an informational message.\n   *\n   * @param tag Message category.\n   * @param message Message to log.\n   * @param optionalParams Optional parameters to log.\n   */\n  info<T extends string>(tag: T, message: unknown, ...optionalParams: unknown[]): void {\n    this.log(Level.INFO, tag, message, optionalParams);\n  }\n\n  /**\n   * Logs a trace message.\n   *\n   * @param tag Message category.\n   * @param message Message to log.\n   * @param optionalParams Optional parameters to log.\n   */\n  trace<T extends string>(tag: T, message: unknown, ...optionalParams: unknown[]): void {\n    this.log(Level.TRACE, tag, message, optionalParams);\n  }\n\n  /**\n   * Logs a warning message.\n   *\n   * @param tag Message category.\n   * @param message Message to log.\n   * @param optionalParams Optional parameters to log.\n   */\n  warn<T extends string>(tag: T, message: unknown, ...optionalParams: unknown[]): void {\n    this.log(Level.WARN, tag, message, optionalParams);\n  }\n\n  /**\n   * Internal log method.\n   *\n   * @param level Numeric log level.\n   * @param tag Message category.\n   * @param message Message to log.\n   * @param optionalParams Optional parameters to log.\n   */\n  private log<T extends string>(level: Level, tag: T, message: unknown, optionalParams: unknown[]): void {\n    // Register the tag if not already present using the 'in' operator\n    if (!(tag in tagRegistry)) {\n      tagRegistry[tag] = tag;\n      console.debug(`logger: unregistered tag, \"${tag}\"`);\n    }\n\n    // Early exit if no callback is defined\n    if (!this._callback) {\n      return;\n    }\n\n    // Determine the effective log level for the tag\n    const effectiveLevel = this._tagToLevel[tag] ?? this._defaultLevel;\n\n    if (level < effectiveLevel) {\n      return;\n    }\n\n    // Convert numeric level to string for the callback\n    const levelStr = this.levelToString(level);\n\n    // Execute the callback within a try-catch block to safeguard against errors\n    try {\n      this._callback(levelStr, tag, message, optionalParams);\n    } catch (err) {\n      console.error(`Error in log callback for tag \"${tag}\":`, err);\n    }\n  }\n}\n\n/**\n * Singleton Log instance.\n */\nexport const log = new Log();\n\n/**\n * Tag registry.\n */\nexport const tag = tagRegistry;\n"],
  "mappings": "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",
  "names": ["Level", "LogLevel", "tag"]
}
