/**
 * @author Ray Martone
 * @copyright Copyright (c) 2019-2025 Ray Martone
 * @license MIT
 * @description Log adapter providing level-based filtering and tagging.
 */var u=(r=>(r.TRACE="TRACE",r.DEBUG="DEBUG",r.INFO="INFO",r.WARN="WARN",r.ERROR="ERROR",r.OFF="OFF",r))(u||{}),o=new Set,d=new Proxy({},{get(a,e){if(typeof e=="string")return o.has(e)||(o.add(e),console.debug(`logger: unregistered tag, "${e}"`)),e},ownKeys(){return Array.from(o)},getOwnPropertyDescriptor(){return{enumerable:!0,configurable:!0}}}),s=new Map([["TRACE",1],["DEBUG",2],["INFO",3],["WARN",4],["ERROR",5],["OFF",6]]),g=new Map([[1,"TRACE"],[2,"DEBUG"],[3,"INFO"],[4,"WARN"],[5,"ERROR"],[6,"OFF"]]),i=class{_defaultLevel=1;_tagToLevel=new Map;_callback;parseLevel(e){return s.get(e)??this._defaultLevel}levelToString(e){return g.get(e)??g.get(this._defaultLevel)}init(e,n){if(e)for(let t in e){let l=e[t];s.has(l)?this._tagToLevel.set(t,s.get(l)):(console.warn(`Invalid log level "${l}" for tag "${t}". Using default (${this.levelToString(this._defaultLevel)}).`),this._tagToLevel.set(t,this._defaultLevel)),o.add(t)}return n!==void 0&&(this._callback=n),this}getEffectiveLogLevel(e){return this._tagToLevel.has(e)?this._tagToLevel.get(e):(o.has(e)||console.debug(`logger: unregistered tag, "${e}"`),this._defaultLevel)}log(e,n,t,l){if(!this._callback)return;let v=this.getEffectiveLogLevel(n);if(e<v)return;let r=this.levelToString(e);try{this._callback(r,n,t,l)}catch(R){console.error(`Error in log callback for tag "${n}":`,R)}}debug(e,n,...t){this.log(2,e,n,t)}error(e,n,...t){this.log(5,e,n,t)}info(e,n,...t){this.log(3,e,n,t)}trace(e,n,...t){this.log(1,e,n,t)}warn(e,n,...t){this.log(4,e,n,t)}},L=new i;export{i as Log,u as LogLevel,L as log,d as tag};
//# sourceMappingURL=index.esm.js.map
