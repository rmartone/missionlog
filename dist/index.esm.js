/**
 * @author Ray Martone
 * @copyright Copyright (c) 2019-2025 Ray Martone
 * @license MIT
 * @description Log adapter providing level-based filtering and tagging.
 */var R=(r=>(r.TRACE="TRACE",r.DEBUG="DEBUG",r.INFO="INFO",r.WARN="WARN",r.ERROR="ERROR",r.OFF="OFF",r))(R||{}),o=new Set,u=new Proxy({},{get(g,e){if(typeof e=="string")return o.has(e)||(o.add(e),console.debug(`logger: unregistered tag, "${e}"`)),e},ownKeys(){return Array.from(o)},getOwnPropertyDescriptor(){return{enumerable:!0,configurable:!0}}}),i=new Map([["TRACE",1],["DEBUG",2],["INFO",3],["WARN",4],["ERROR",5],["OFF",6]]),v=new Map([[1,"TRACE"],[2,"DEBUG"],[3,"INFO"],[4,"WARN"],[5,"ERROR"],[6,"OFF"]]),s=class{_defaultLevel=1;_tagToLevel=new Map;_callback;levelToString(e){return v.get(e)}init(e,n){if(e)for(let t in e){let l=e[t];i.has(l)?this._tagToLevel.set(t,i.get(l)):(console.warn(`Invalid log level "${l}" for tag "${t}". Using default (${this.levelToString(this._defaultLevel)}).`),this._tagToLevel.set(t,this._defaultLevel)),o.add(t)}return n!==void 0&&(this._callback=n),this}getEffectiveLogLevel(e){return this._tagToLevel.has(e)?this._tagToLevel.get(e):(o.has(e)||console.debug(`logger: unregistered tag, "${e}"`),this._defaultLevel)}log(e,n,t,l){if(!this._callback)return;let a=this.getEffectiveLogLevel(n);if(e<a)return;let r=this.levelToString(e);this._callback(r,n,t,l)}debug(e,n,...t){this.log(2,e,n,t)}error(e,n,...t){this.log(5,e,n,t)}info(e,n,...t){this.log(3,e,n,t)}trace(e,n,...t){this.log(1,e,n,t)}warn(e,n,...t){this.log(4,e,n,t)}},d=new s;export{s as Log,R as LogLevel,d as log,u as tag};
//# sourceMappingURL=index.esm.js.map
