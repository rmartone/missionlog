/**
 * @author Ray Martone
 * @copyright Copyright (c) 2019-2025 Ray Martone
 * @license MIT
 * @description Log adapter providing level-based filtering and tagging.
 */var u=(r=>(r.TRACE="TRACE",r.DEBUG="DEBUG",r.INFO="INFO",r.WARN="WARN",r.ERROR="ERROR",r.OFF="OFF",r))(u||{}),o=new Set,d=new Proxy({},{get(a,e){if(typeof e=="string")return o.has(e)||(o.add(e),console.debug(`logger: unregistered tag, "${e}"`)),e},ownKeys(){return Array.from(o)},getOwnPropertyDescriptor(){return{enumerable:!0,configurable:!0}}}),s=new Map([["TRACE",1],["DEBUG",2],["INFO",3],["WARN",4],["ERROR",5],["OFF",6]]),g=new Map([[1,"TRACE"],[2,"DEBUG"],[3,"INFO"],[4,"WARN"],[5,"ERROR"],[6,"OFF"]]),i=class{_defaultLevel=1;_tagToLevel=new Map;_callback;parseLevel(e){return s.get(e)??this._defaultLevel}levelToString(e){return g.get(e)??g.get(this._defaultLevel)}init(e,t){if(e)for(let n in e){let l=e[n];s.has(l)?this._tagToLevel.set(n,s.get(l)):(console.warn(`Invalid log level "${l}" for tag "${n}". Using default (${this.levelToString(this._defaultLevel)}).`),this._tagToLevel.set(n,this._defaultLevel)),o.add(n)}return t!==void 0&&(this._callback=t),this}getEffectiveLogLevel(e){let t=this._tagToLevel.get(e);return t===void 0?(console.debug(`logger: unregistered tag, "${e}"`),this._defaultLevel):t}log(e,t,n,l){if(!this._callback)return;let v=this.getEffectiveLogLevel(t);if(e<v)return;let r=this.levelToString(e);try{this._callback(r,t,n,l)}catch(R){console.error(`Error in log callback for tag "${t}":`,R)}}debug(e,t,...n){this.log(2,e,t,n)}error(e,t,...n){this.log(5,e,t,n)}info(e,t,...n){this.log(3,e,t,n)}trace(e,t,...n){this.log(1,e,t,n)}warn(e,t,...n){this.log(4,e,t,n)}},c=new i;export{i as Log,u as LogLevel,c as log,d as tag};
//# sourceMappingURL=index.esm.js.map
